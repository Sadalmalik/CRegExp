[EN]() | [RU]()

# Оглавление
* [Введение](#введение)
* [Выводы](#выводы)
* [Реализация](#реализация)


# Введение
[К оглавлению](#Оглавление)
Данный проект представляет собой мою попытку освоить использование ChatGPT для выполнения некоторой работы (в данном случае -  разработка небольшой библиотеки). Я использовал платный Chat GPT-4 с сайта [openai.com](https://chat.openai.com/). В качестве  рабочей задачи я выбрал "создание базовой реализации регулярных выражений на C".

Изначально я старался весь код делать через GPT, но после ряда итераций стали очевидны многие проблемы связанные с этим, поэтому я сменил подход на использование GPT для консультирования и проверки кода. В итоге совместными усилиями (под конец - только моими) нам удалось реализовать версию регулярных выражений, поддерживающую следующие символы: `. ? * ( )`


# Выводы
[К оглавлению](#Оглавление)
Прежде всего самый важный вывод - я выбрал задачу, которая оказалась не простой для меня самого. С одной стороны возможно это не позволило мне в полной мере оценить точность некоторых ответов GPT, а с другой - у нас получился эксперимент приближенный к реальным условиям.

По итогу применение Chat GPT в работе имеет огромное колличество нюансов и особенностей, которые помещают его в разряд не самого плохого инструмента.

* Прежде всего GPT не обладает сознанием и пониманием как таковыми. Он впринципе не понимает, что он  делает, но ведет себя абсолютно уверено. Потому что так обучен.
* У него нет абстрактного воображения - GPT не мог представить в голове (по причине её отсутствия) структуру дерева парсинга, порядок следования состояний и смысл этого порядка. Как результат - он с полной уверенностью выдавал код, который абсолютно невалидно выстраивал связи между объектами.
* GPT постоянно ошибается. Причем максимально по человечески. И со временем ошибки начинают множится (по причине ограничения памяти GPT)
  * Так например он выдал код с неинициализированными переменными. Мне потребовалось сначала пол часа что бы найти причину падения программы. А затем еще дважды задать наводящие вопросы что бы GPT заметил ошибку и предложил исправление. Он не анализирует код как программа. И он не анализирует его как программист - не прикладывает усилий что бы найти и устранить проблемы. 
  * Это вообще одна из больших проблем. Он не прикладывает усилий что бы решать какие-либо задачи. Он просто генерирует ответ. Как следствие он не способен решать задачи без большого числа наводящих вопросов, которые будут вести его к нужным ответам.
* Помимо этого у GPT есть еще одна "ленивая" черта - он всегда старается дать как можно более упрощенный ответ. Особенно это касается задач написания кода. Подозреваю, что это связанно с тем, как работают языковые модели в целом - вполне вероятно что если заставить выдать его более длинный ответ - он начнет сходить с ума.

В сущности GPT - это такой слепок коллективного сознания интернета.
Копия Разума Улья, имитирующая его ответы в некотором виде, но не осознающая ничего и не умеющая ничего кроме как говорить. У людей связанная речь без сознания называется Шизофазией :)

Мой вывод:
GPT нельзя рассматривать как ИИ потому как он не обладает никакими чертами разумности.
Это просто черный ящак наполненный очень умной болтовней.
В общем - хайп вокруг GPT крайне перегрет и переоценен.

Тем не менее GPT может быть очень полезен в некоторых задачах.
* Прежде всего - это очень хороший метод организации поиска информации.
  * Когда человек не может точно сформулировать вопрос - GPT может выдать ряд приближенных вариантов ответов, что может сильно помочь человеку сдвинуться с мертвой точки.
* Несмотря на то, что GPT постоянно ошибается - он может быть крайне полезен для генерации идей


# Реализация
[К оглавлению](#Оглавление)
Реализация находится в файлах *light_regexp.hpp* и *light_regexp.cpp*.

В качестве способа реализации регулярных выражений была выбрана простой конечный автомат с проверкой соответствия символа состоянию.



Пример использования:
```cpp
#include "light_regexp.hpp"

...

LiRex::TRegex* reg = LiRex::Create("abc(xyz)*");
LiRex::TMatch match = LiRex::Match(reg, "abcxyzxyz");
if (match.success)
{
    int count = match.groups.size();
    printf("Match founded: %s\nGroups: %d", match.match.c_str(), count);
    for (int i=0 ; i<count ; i++)
        std::printf("  %d: '%s'\n", i, m.groups[i].c_str());
}

...

LiRex::Destroy(reg); // Don't forget to delete regex!
```
